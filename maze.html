<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Maze (Labyrinth) Game</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f5f5e6;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    nav {
      display: flex;
      justify-content: center;
      padding: 20px 0;
      background: #f5f5e6;
    }

    nav a {
      color: #333;
      text-decoration: none;
      margin: 0 20px;
      font-size: 18px;
      transition: color 0.3s ease;
    }

    nav a:hover { color: #000; text-decoration: underline; }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    #hud {
      display: flex;
      gap: 20px;
      align-items: center;
      color: #333;
      font-size: 16px;
    }

    #maze-wrap {
      border: 4px solid #333;
      border-radius: 8px;
      background: #f5f5e6;
      overflow: hidden;
    }

    #maze {
      display: block;
      background: #fff; /* maze background */
    }

    #restart {
      background: #333;
      color: #fff;
      border: none;
      padding: 10px 18px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease;
    }
    #restart:hover { background: #000; transform: translateY(-2px); }

    #tip { color: #555; font-size: 14px; }
  </style>
</head>
<body>

<nav>
  <a href="index.html">Home</a>
</nav>

<main>
  <div id="hud">
    <span id="status">Find the green exit!</span>
    <span>Time: <strong id="time">0.0s</strong></span>
    <span>Moves: <strong id="moves">0</strong></span>
    <button id="restart">New maze</button>
  </div>

  <div id="maze-wrap">
    <canvas id="maze" width="800" height="600"></canvas>
  </div>

  <div id="tip">Use arrow keys or WASD. You canâ€™t move through walls.</div>
</main>

<script>
  // Config
  const cols = 32;        // maze columns
  const rows = 24;        // maze rows
  const cellSize = 25;    // pixels per cell (25*32=800, 25*24=600)
  const wallColor = "#000";
  const bgColor = "#fff";
  const playerColor = "#333";
  const exitColor = "green";

  // Canvas
  const canvas = document.getElementById("maze");
  const ctx = canvas.getContext("2d");

  // HUD
  const statusEl = document.getElementById("status");
  const timeEl = document.getElementById("time");
  const movesEl = document.getElementById("moves");
  const restartBtn = document.getElementById("restart");

  // Maze data: each cell has walls: top,right,bottom,left
  let grid, player, exit, moves, startTime, timerId, gameOver = false;

  function initGrid() {
    grid = [];
    for (let y = 0; y < rows; y++) {
      const row = [];
      for (let x = 0; x < cols; x++) {
        row.push({ x, y, visited: false, walls: [true, true, true, true] });
      }
      grid.push(row);
    }
  }

  function neighbors(cell) {
    const { x, y } = cell;
    const list = [];
    if (y > 0) list.push(grid[y - 1][x]);         // top
    if (x < cols - 1) list.push(grid[y][x + 1]);  // right
    if (y < rows - 1) list.push(grid[y + 1][x]);  // bottom
    if (x > 0) list.push(grid[y][x - 1]);         // left
    return list.filter(n => !n.visited);
  }

  // Recursive backtracker (iterative) to carve maze
  function generateMaze() {
    const stack = [];
    const start = grid[0][0];
    start.visited = true;
    stack.push(start);

    while (stack.length > 0) {
      const current = stack[stack.length - 1];
      const unvisited = neighbors(current);

      if (unvisited.length > 0) {
        const next = unvisited[Math.floor(Math.random() * unvisited.length)];
        // remove walls between current and next
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        if (dx === 1) { current.walls[1] = false; next.walls[3] = false; }      // right
        else if (dx === -1) { current.walls[3] = false; next.walls[1] = false; } // left
        else if (dy === 1) { current.walls[2] = false; next.walls[0] = false; }  // bottom
        else if (dy === -1) { current.walls[0] = false; next.walls[2] = false; } // top

        next.visited = true;
        stack.push(next);
      } else {
        stack.pop();
      }
    }
  }

  function drawMaze() {
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = wallColor;
    ctx.lineWidth = 2;
    ctx.beginPath();

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = grid[y][x];
        const px = x * cellSize;
        const py = y * cellSize;
        // walls: top,right,bottom,left
        if (cell.walls[0]) { ctx.moveTo(px, py); ctx.lineTo(px + cellSize, py); }
        if (cell.walls[1]) { ctx.moveTo(px + cellSize, py); ctx.lineTo(px + cellSize, py + cellSize); }
        if (cell.walls[2]) { ctx.moveTo(px + cellSize, py + cellSize); ctx.lineTo(px, py + cellSize); }
        if (cell.walls[3]) { ctx.moveTo(px, py + cellSize); ctx.lineTo(px, py); }
      }
    }
    ctx.stroke();

    // Exit
    ctx.fillStyle = exitColor;
    ctx.fillRect(exit.x * cellSize + 6, exit.y * cellSize + 6, cellSize - 12, cellSize - 12);

    // Player
    ctx.fillStyle = playerColor;
    ctx.beginPath();
    ctx.arc(
      player.x * cellSize + cellSize / 2,
      player.y * cellSize + cellSize / 2,
      cellSize * 0.35, 0, Math.PI * 2
    );
    ctx.fill();
  }

  function canMove(from, dir) {
    // dir: 0=top,1=right,2=bottom,3=left
    if (from.walls[dir]) return false;
    let nx = from.x, ny = from.y;
    if (dir === 0) ny--; else if (dir === 1) nx++; else if (dir === 2) ny++; else nx--;
    if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return false;
    return true;
  }

  function movePlayer(dir) {
    if (gameOver) return;
    const cell = grid[player.y][player.x];
    if (!canMove(cell, dir)) return;

    if (dir === 0) player.y--;
    else if (dir === 1) player.x++;
    else if (dir === 2) player.y++;
    else player.x--;

    moves++;
    movesEl.textContent = moves;
    drawMaze();
    checkWin();
  }

  function checkWin() {
    if (player.x === exit.x && player.y === exit.y) {
      gameOver = true;
      const elapsed = (performance.now() - startTime) / 1000;
      statusEl.textContent = `Done! Time: ${elapsed.toFixed(1)}s, Moves: ${moves}`;
      clearInterval(timerId);
    }
  }

  function startTimer() {
    startTime = performance.now();
    timerId = setInterval(() => {
      const t = (performance.now() - startTime) / 1000;
      timeEl.textContent = `${t.toFixed(1)}s`;
    }, 100);
  }

  function newMaze() {
    clearInterval(timerId);
    gameOver = false;
    moves = 0;
    movesEl.textContent = "0";
    timeEl.textContent = "0.0s";
    statusEl.textContent = "Find the green exit!";
    initGrid();
    generateMaze();
    player = { x: 0, y: 0 };
    exit = { x: cols - 1, y: rows - 1 };
    drawMaze();
    startTimer();
  }

  // Controls: Arrow keys / WASD
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowup" || k === "w") movePlayer(0);
    else if (k === "arrowright" || k === "d") movePlayer(1);
    else if (k === "arrowdown" || k === "s") movePlayer(2);
    else if (k === "arrowleft" || k === "a") movePlayer(3);
  });

  document.getElementById("restart").addEventListener("click", newMaze);

  // First load
  newMaze();
</script>

</body>

</html>
